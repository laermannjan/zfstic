#!/usr/bin/env bash
# zfstic — ZFS snapshot management inspired by restic
# https://github.com/laermannjan/zfstic
#
# Requirements: bash 4+, awk (gawk/mawk/BSD awk with strftime), zfs in PATH
set -euo pipefail

VERSION="0.3.1"

# ──────────────────────────────────────────────────────────────────────────────
# Usage
# ──────────────────────────────────────────────────────────────────────────────

usage() {
    cat <<'EOF'
zfstic — ZFS snapshot management inspired by restic

USAGE:
    zfstic <command> [options]

COMMANDS:
    forget    Remove snapshots according to a retention policy
    snapshot  Create a new snapshot
    version   Show version
    help      Show this help

Run 'zfstic <command> --help' for command-specific help.
EOF
}

usage_forget() {
    cat <<'EOF'
zfstic forget — Remove snapshots according to a retention policy

USAGE:
    zfstic forget [options] <dataset>

OPTIONS:
    --keep-last    n    Keep the n most recent snapshots unconditionally
    --keep-hourly  n    Keep the earliest snapshot per hour for the last n hours
    --keep-daily   n    Keep the earliest snapshot per day for the last n days
    --keep-weekly  n    Keep the earliest snapshot per ISO week for the last n weeks
    --keep-monthly n    Keep the earliest snapshot per month for the last n months
    --keep-yearly  n    Keep the earliest snapshot per year for the last n years
    -r, --recursive     Apply to dataset and all child datasets independently
    -n, --dry-run       Show what would be removed without actually removing
    --prefix <pfx>      Only consider snapshots whose name starts with <pfx>
                        Default: "zfstic-". Pass --prefix "" to manage all snapshots.
    --timezone <tz>     Timezone for computing period boundaries (e.g. UTC, America/New_York)
                        Default: system local time
    -h, --help          Show this help

NOTES:
    At least one --keep-* option is required.

    --keep-daily n keeps the oldest snapshot in each of the last n calendar days.
    Days with no snapshots contribute nothing - fewer retained snapshots, not more
    time covered. zfstic keeps the oldest per period, not the newest, so each
    policy anchors to a distinct point in time.

    The newest snapshot is always kept regardless of policy (shown as "latest").
    Safety net - not a substitute for correct replication policy design.

    When using with syncoid (or zfs send directly):

    Incremental sends only ship blocks born after a reference point (txg). The
    source needs a snapshot or bookmark at that point; the destination needs the
    actual snapshot, because the stream omits blocks already present there.

    syncoid by default creates a syncoid_-prefixed snapshot on both sides before
    each send and deletes old ones -- these serve as the common anchor for
    incremental sends. zfstic's default --prefix zfstic- means forget won't
    touch them. For lighter source-side footprint, syncoid --create-bookmark
    --no-sync-snap creates a bookmark on the source with no sync snapshot on
    either side; the destination still needs its snapshot -- and forget's
    keep-latest guarantees it survives, since the youngest remote snapshot is
    exactly the one the bookmark points to. You can also manage everything
    manually with zfs send and zfs bookmark.

    forget always keeps the newest snapshot regardless of policy (shown as
    "latest"), so the remote's anchor is never accidentally removed. For
    coverage -- ensuring remote gets the granularity you want -- run replication
    before forgetting locally.

        zfstic snapshot tank/data
        syncoid tank/data backup@remote:tank/backup     # replicate first
        zfstic forget tank/data --keep-last 5 --keep-daily 7
        ssh backup@remote zfstic forget tank/backup \
            --keep-monthly 12 --keep-yearly 5           # prune remote independently

        zfstic snapshot tank/data
        syncoid tank/data backup@remote:tank/backup     # replicate first
        zfstic forget tank/data --keep-daily 8          # then prune local
        ssh backup@remote zfstic forget tank/backup \
            --keep-monthly 12 --keep-yearly 5           # prune remote independently

EXAMPLES:
    # Keep 24 hourly + 7 daily locally, preview first
    zfstic forget --keep-hourly 24 --keep-daily 7 --dry-run tank/data

    # Apply recursively to dataset and all children
    zfstic forget --keep-hourly 24 --keep-daily 7 -r tank

    # Manage ALL snapshots including sanoid/manual (clear the default prefix)
    zfstic forget --keep-daily 7 --prefix "" tank/data
EOF
}

usage_snapshot() {
    cat <<'EOF'
zfstic snapshot — Create a new ZFS snapshot

USAGE:
    zfstic snapshot [options] <dataset>

OPTIONS:
    --label <name>      Append a label to the snapshot name
    --timezone <tz>     Use this timezone for the timestamp (e.g. America/New_York)
                        Default: system local time
    -r, --recursive     Snapshot dataset and all children atomically
    -h, --help          Show this help

SNAPSHOT NAMING:
    Without label:  <dataset>@zfstic-2026-02-22T10:00:00CET
    With label:     <dataset>@zfstic-2026-02-22T10:00:00CET-migration

    Timestamps use local time with a timezone abbreviation. forget defaults to
    --prefix zfstic- so these snapshots are automatically scoped.

EXAMPLES:
    zfstic snapshot tank/data
    zfstic snapshot --label migration tank/data
    zfstic snapshot -r tank
    zfstic snapshot --timezone UTC tank/data
EOF
}

# ──────────────────────────────────────────────────────────────────────────────
# apply_retention <dataset> <keep_last> <keep_hourly> <keep_daily>
#                 <keep_weekly> <keep_monthly> <keep_yearly> <prefix> <dry_run> <timezone>
#
# Lists snapshots for the given dataset, applies retention policies via a single
# awk pass, prints the keep/remove plan, and destroys the removes (unless dry_run).
# ──────────────────────────────────────────────────────────────────────────────

apply_retention() {
    local dataset="$1"
    local keep_last="$2"
    local keep_hourly="$3"
    local keep_daily="$4"
    local keep_weekly="$5"
    local keep_monthly="$6"
    local keep_yearly="$7"
    local prefix="$8"
    local dry_run="${9}"
    local timezone="${10}"

    # List snapshots for this dataset only (no recursion; caller handles that).
    # -p gives parseable (epoch) timestamps. Sort newest-first.
    local raw
    raw=$(zfs list -H -p -t snapshot -o name,creation "$dataset" 2>/dev/null \
        | sort -t$'\t' -k2 -rn) || {
        printf 'warning: could not list snapshots for %s\n' "$dataset" >&2
        return 0
    }

    # Filter by prefix when requested
    if [[ -n "$prefix" ]]; then
        raw=$(printf '%s\n' "$raw" | awk -F'\t' -v pfx="$prefix" '{
            n = split($1, a, "@")
            if (substr(a[n], 1, length(pfx)) == pfx) print
        }')
    fi

    [[ -z "$raw" ]] && return 0

    # Two-phase awk pass (input: newest-first).
    # BEGIN: pre-compute the last N calendar periods per policy using systime().
    # Phase 1 (main body): record which bucket each snapshot falls into.
    # Phase 2 (END): for each in-scope bucket, select the oldest snapshot.
    #   Iterating i=1..NR over newest-first input, last-write-wins = oldest.
    local results
    results=$(
        [[ -n "$timezone" ]] && export TZ="$timezone"
        printf '%s\n' "$raw" | awk \
        -v kl="$keep_last"    \
        -v kh="$keep_hourly"  \
        -v kd="$keep_daily"   \
        -v kw="$keep_weekly"  \
        -v km="$keep_monthly" \
        -v ky="$keep_yearly"  \
    'BEGIN {
        now = systime()
        if (kh > 0) {
            for (i = 0; i < kh; i++)
                sh[strftime("%Y%m%d%H", now - i * 3600)] = 1
        }
        if (kd > 0) {
            for (i = 0; i < kd; i++)
                sd[strftime("%Y%m%d", now - i * 86400)] = 1
        }
        if (kw > 0) {
            # Anchor to Monday of the current week then step back kw weeks.
            # %V = ISO week number; %Y instead of %G for mawk compat
            # (minor year-boundary edge case on Dec 28 - Jan 3 accepted)
            dow = strftime("%w", now) + 0
            days_to_mon = (dow == 0) ? 6 : (dow - 1)
            mon = now - days_to_mon * 86400
            for (i = 0; i < kw; i++)
                sw[strftime("%Y%V", mon - i * 7 * 86400)] = 1
        }
        if (km > 0) {
            cy = strftime("%Y", now) + 0
            cm = strftime("%m", now) + 0
            for (i = 0; i < km; i++) {
                y = cy; m = cm - i
                while (m <= 0) { m += 12; y-- }
                sm[sprintf("%04d%02d", y, m)] = 1
            }
        }
        if (ky > 0) {
            cy = strftime("%Y", now) + 0
            for (i = 0; i < ky; i++)
                sy[sprintf("%04d", cy - i)] = 1
        }
    }
    {
        full  = $1
        epoch = $2
        at    = index(full, "@")
        snap  = substr(full, at + 1)
        dt    = strftime("%Y-%m-%d %H:%M:%S", epoch)

        snaps[NR]  = snap
        epochs[NR] = epoch
        dts[NR]    = dt

        if (kh > 0) hb[NR] = strftime("%Y%m%d%H", epoch)
        if (kd > 0) db[NR] = strftime("%Y%m%d",   epoch)
        if (kw > 0) wb[NR] = strftime("%Y%V",      epoch)
        if (km > 0) mb[NR] = strftime("%Y%m",      epoch)
        if (ky > 0) yb[NR] = strftime("%Y",        epoch)
    }
    END {
        for (i = 1; i <= NR; i++) {
            if (kh > 0 && (hb[i] in sh)) hk[hb[i]] = i
            if (kd > 0 && (db[i] in sd)) dk[db[i]] = i
            if (kw > 0 && (wb[i] in sw)) wk[wb[i]] = i
            if (km > 0 && (mb[i] in sm)) mk[mb[i]] = i
            if (ky > 0 && (yb[i] in sy)) yk[yb[i]] = i
        }

        for (i = 1; i <= NR; i++) {
            reasons = ""

            # keep-last: N most recent = first N rows in newest-first order
            if (kl > 0 && i <= kl)
                reasons = "last"

            if (kh > 0 && (hb[i] in hk) && hk[hb[i]] == i)
                reasons = reasons (reasons ? ", " : "") "hourly"
            if (kd > 0 && (db[i] in dk) && dk[db[i]] == i)
                reasons = reasons (reasons ? ", " : "") "daily"
            if (kw > 0 && (wb[i] in wk) && wk[wb[i]] == i)
                reasons = reasons (reasons ? ", " : "") "weekly"
            if (km > 0 && (mb[i] in mk) && mk[mb[i]] == i)
                reasons = reasons (reasons ? ", " : "") "monthly"
            if (ky > 0 && (yb[i] in yk) && yk[yb[i]] == i)
                reasons = reasons (reasons ? ", " : "") "yearly"

            # Safety net: always keep at least one snapshot
            if (i == 1 && reasons == "")
                reasons = "latest"

            if (reasons != "") {
                print "keep"   "\t" snaps[i] "\t" epochs[i] "\t" reasons "\t" dts[i]
            } else {
                print "remove" "\t" snaps[i] "\t" epochs[i] "\t"          "\t" dts[i]
            }
        }
    }')

    local n_keep n_remove
    n_keep=$(awk -F'\t' '$1=="keep"  {c++} END{print c+0}' <<< "$results")
    n_remove=$(awk -F'\t' '$1=="remove"{c++} END{print c+0}' <<< "$results")

    printf '\n  %s:\n' "$dataset"
    while IFS=$'\t' read -r action snap _epoch reasons _dt; do
        if [[ "$action" == "keep" ]]; then
            printf '    %-6s  %s\t[%s]\n' "$action" "$snap" "$reasons"
        else
            printf '    %-6s  %s\n' "$action" "$snap"
        fi
    done <<< "$results"
    if [[ "$dry_run" == "true" ]]; then
        printf '    --- %d keep, %d remove --- (dry run)\n' "$n_keep" "$n_remove"
    else
        printf '    --- %d keep, %d remove ---\n' "$n_keep" "$n_remove"
    fi

    if [[ "$dry_run" != "true" && "$n_remove" -gt 0 ]]; then
        local errors=0
        while IFS=$'\t' read -r action snap _epoch _reasons _dt; do
            [[ "$action" != "remove" ]] && continue
            if ! zfs destroy "${dataset}@${snap}"; then
                printf 'error: failed to destroy %s@%s\n' "$dataset" "$snap" >&2
                errors=$(( errors + 1 ))
            fi
        done <<< "$results"
        [[ "$errors" -eq 0 ]]
    fi
}

# ──────────────────────────────────────────────────────────────────────────────
# forget command
# ──────────────────────────────────────────────────────────────────────────────

cmd_forget() {
    local keep_last=0 keep_hourly=0 keep_daily=0 keep_weekly=0
    local keep_monthly=0 keep_yearly=0
    local recursive=false dry_run=false prefix="zfstic-" dataset="" timezone=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --keep-last)    keep_last="${2:?'--keep-last requires a value'}";    shift 2 ;;
            --keep-hourly)  keep_hourly="${2:?'--keep-hourly requires a value'}";  shift 2 ;;
            --keep-daily)   keep_daily="${2:?'--keep-daily requires a value'}";   shift 2 ;;
            --keep-weekly)  keep_weekly="${2:?'--keep-weekly requires a value'}";  shift 2 ;;
            --keep-monthly) keep_monthly="${2:?'--keep-monthly requires a value'}"; shift 2 ;;
            --keep-yearly)  keep_yearly="${2:?'--keep-yearly requires a value'}";  shift 2 ;;
            -r|--recursive) recursive=true; shift ;;
            -n|--dry-run)   dry_run=true;   shift ;;
            --prefix)       prefix="${2:?'--prefix requires a value'}"; shift 2 ;;
            --timezone)     timezone="${2:?'--timezone requires a value'}"; shift 2 ;;
            -h|--help)      usage_forget; return 0 ;;
            -*)  printf 'error: unknown option: %s\n' "$1" >&2; return 1 ;;
            *)   dataset="$1"; shift ;;
        esac
    done

    if [[ -z "$dataset" ]]; then
        printf 'error: dataset argument required\n' >&2
        usage_forget >&2
        return 1
    fi

    local policy_sum=$(( keep_last + keep_hourly + keep_daily + keep_weekly + keep_monthly + keep_yearly ))
    if [[ "$policy_sum" -eq 0 ]]; then
        printf 'error: no retention policy specified; provide at least one --keep-* flag\n' >&2
        return 1
    fi

    # Collect datasets: given dataset only, or it plus all descendants
    local datasets
    if [[ "$recursive" == "true" ]]; then
        datasets=$(zfs list -H -r -o name -t filesystem,volume "$dataset")
    else
        datasets="$dataset"
    fi

    local errors=0
    while IFS= read -r ds; do
        apply_retention "$ds" \
            "$keep_last" "$keep_hourly" "$keep_daily" \
            "$keep_weekly" "$keep_monthly" "$keep_yearly" \
            "$prefix" "$dry_run" "$timezone" || errors=$(( errors + 1 ))
    done <<< "$datasets"

    if [[ "$dry_run" == "true" ]]; then
        printf '\n[dry run] No snapshots were removed.\n'
    fi

    [[ "$errors" -eq 0 ]]
}

# ──────────────────────────────────────────────────────────────────────────────
# snapshot command
# ──────────────────────────────────────────────────────────────────────────────

cmd_snapshot() {
    local label="" recursive=false dataset="" timezone=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --label)        label="${2:?'--label requires a value'}"; shift 2 ;;
            --timezone)     timezone="${2:?'--timezone requires a value'}"; shift 2 ;;
            -r|--recursive) recursive=true; shift ;;
            -h|--help)      usage_snapshot; return 0 ;;
            -*)  printf 'error: unknown option: %s\n' "$1" >&2; return 1 ;;
            *)   dataset="$1"; shift ;;
        esac
    done

    if [[ -z "$dataset" ]]; then
        printf 'error: dataset argument required\n' >&2
        return 1
    fi

    local ts snap_name off
    local tz=()
    [[ -n "$timezone" ]] && tz=(env "TZ=$timezone")

    off=$("${tz[@]}" date +%z)
    if [[ "$off" == -* ]]; then
        off="GMT-${off:1:2}:${off:3:2}"
    else
        off="GMT${off:1:2}:${off:3:2}"
    fi

    ts=$("${tz[@]}" date "+%Y-%m-%dT%H:%M:%S${off}")

    snap_name="zfstic-${ts}"
    [[ -n "$label" ]] && snap_name="${snap_name}-${label}"

    local args=()
    [[ "$recursive" == "true" ]] && args+=(-r)

    zfs snapshot "${args[@]}" "${dataset}@${snap_name}"
    printf 'Created %s@%s\n' "$dataset" "$snap_name"
}

# ──────────────────────────────────────────────────────────────────────────────
# Entry point
# ──────────────────────────────────────────────────────────────────────────────

main() {
    if [[ $# -eq 0 ]]; then usage; exit 0; fi

    case "$1" in
        forget)            shift; cmd_forget "$@" ;;
        snapshot)          shift; cmd_snapshot "$@" ;;
        help|-h|--help)    usage ;;
        version|--version) printf 'zfstic %s\n' "$VERSION" ;;
        *) printf 'error: unknown command: %s\n' "$1" >&2; usage >&2; exit 1 ;;
    esac
}

main "$@"
